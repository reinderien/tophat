using System.Runtime.Versioning;
[assembly: TargetFramework(".NETFramework,Version=v4.5.1", FrameworkDisplayName = ".NET Framework 4.5.1")]

namespace ZipTest
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.IO.Compression;
    using System.Net;
    using System.Web;

    class PartialHTTPStream : Stream, IDisposable
    {
        Stream stream;
        WebResponse resp;
        HttpWebRequest req;
        long cacheRemaining = 0;
        const long cachelen = 1024;

        public string Url { get; private set; }
        public override bool CanRead { get { return true; } }
        public override bool CanWrite { get { return false; } }
        public override bool CanSeek { get { return true; } }

        long position = 0;
        public override long Position
        {
            get { return position; }
            set
            {
                long delta = value - position;
                if (delta == 0)
                    return;
                if (delta > 0 && delta < cacheRemaining)
                {
                    Console.WriteLine("Seeking in cache");
                    byte[] dummy = new byte[delta];
                    cacheRemaining -= (int)delta;
                    while (delta > 0)
                    {
                        int nread = stream.Read(dummy, 0, (int)delta);
                        if (nread == 0) throw new IOException();
                        delta -= nread;
                    }
                }
                else cacheRemaining = 0;
                position = value;
                Console.WriteLine("Seek {0}", value);
            }
        }

        long? length;
        public override long Length
        {
            get
            {
                if (length == null)
                {
                    Cancel();
                    req = HttpWebRequest.CreateHttp(Url);
                    req.Method = "HEAD";
                    length = req.GetResponse().ContentLength;
                }
                return length.Value;
            }
        }

        public PartialHTTPStream(string Url) { this.Url = Url; }

        public override void SetLength(long value)
        { throw new NotImplementedException(); }

        public override int Read(byte[] buffer, int offset, int count)
        {
            if (cacheRemaining <= 0)
            {
                Cancel();
                req = HttpWebRequest.CreateHttp(Url);
                cacheRemaining = Math.Min(Length - Position, Math.Max((long)count, cachelen));
                Console.WriteLine("Cache miss - reading {0} @ {1}", cacheRemaining, Position);
                req.AddRange(Position, Position + cacheRemaining - 1);
                resp = req.GetResponse();
                stream = resp.GetResponseStream();
            }

            long newcount = Math.Min(buffer.Length - offset, Math.Min(cacheRemaining, count));
            int nread = stream.Read(buffer, (int)offset, (int)newcount);
            position += nread;
            cacheRemaining -= nread;
            return nread;
        }

        public override void Write(byte[] buffer, int offset, int count)
        { throw new NotImplementedException(); }

        public override long Seek(long pos, SeekOrigin origin)
        {
            switch (origin)
            {
                case SeekOrigin.End:
                    return Position = Length + pos;
                case SeekOrigin.Begin:
                    return Position = pos;
                case SeekOrigin.Current:
                    return Position += pos;
                default:
                    throw new NotImplementedException();
            }
        }

        public override void Flush() { }

        void Cancel()
        {
            if (req != null)
            {
                req.Abort();
                req = null;
            }
            if (resp != null)
            {
                resp.Dispose();
                resp = null;
            }
            if (stream != null)
            {
                stream.Dispose();
                stream = null;
            }
        }

        new void Dispose()
        {
            base.Dispose();
            Cancel();
        }
    }

    class TopHat
    {
        static HashSet<string> files = new HashSet<string>
        {
            "tophat.min.js",
            "index.html"
        };

        static WebClient client;

        static void HandleProxy(string path, HttpListenerResponse response)
        {
            path = path.Replace("/proxy/", "").Replace(":/", "://");
            Console.WriteLine("Proxy fetch {0}", path);
            byte[] content = client.DownloadData(path);
            response.ContentType = client.ResponseHeaders[HttpResponseHeader.ContentType];
            response.ContentLength64 = content.Length;
            response.OutputStream.Write(content, 0, content.Length);
        }

        static void HandleZipProxy(string path, HttpListenerResponse response)
        {
            string[] parts = path.Split(new char[] { '/' }, 3, StringSplitOptions.RemoveEmptyEntries);
            string zippath = parts[1],
                reqpath = parts[2].Replace(":/", "://");
            Console.WriteLine("Zip proxy fetch {0} {1}", reqpath, zippath);
            using (PartialHTTPStream stream = new PartialHTTPStream(reqpath))
            using (ZipArchive arch = new ZipArchive(stream))
            {
                foreach (ZipArchiveEntry entry in arch.Entries)
                {
                    if (entry.Name.Contains(zippath))
                    {
                        response.ContentType = MimeMapping.GetMimeMapping(zippath);
                        response.ContentLength64 = entry.Length;
                        using (Stream zipstream = entry.Open())
                            zipstream.CopyTo(response.OutputStream);
                        break;
                    }
                }
            }
        }

        static void HandleFile(string path, HttpListenerResponse response)
        {
            path = path.TrimStart(new char[] { '/' });
            if (files.Contains(path))
            {
                Console.WriteLine("Content fetch {0}", path);
                using (StreamReader reader = new StreamReader(path))
                {
                    response.ContentType = MimeMapping.GetMimeMapping(path);
                    response.ContentLength64 = reader.BaseStream.Length;
                    reader.BaseStream.CopyTo(response.OutputStream);
                }
            }
            else
                response.StatusCode = (int)HttpStatusCode.NotFound;
        }

        static void Main()
        {
            using (client = new WebClient())
            using (HttpListener listener = new HttpListener())
            {
                listener.Prefixes.Add("http://localhost:8083/");
                listener.Start();

                while (listener.IsListening)
                {
                    Console.WriteLine("Waiting for request...");
                    HttpListenerContext context = listener.GetContext();
                    HttpListenerResponse response = context.Response;
                    Uri uri = context.Request.Url;
                    string path = uri.LocalPath + uri.Query;
                    if (path.StartsWith("/proxy/"))
                        HandleProxy(path, response);
                    else if (path.StartsWith("/zipproxy/"))
                        HandleZipProxy(path, response);
                    else
                        HandleFile(path, response);
                }
            }
        }
    }
}
